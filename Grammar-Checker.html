<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Grammar Checker — tools4.fun</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body { background:#f6f7fb; }
    .tool-card {
      background:#fff; border-radius:12px; padding:18px; box-shadow:0 6px 20px rgba(12,13,26,0.04);
    }
    .result-line { margin-bottom:8px; }
    .suggestion { cursor:pointer; }
    .highlight { background: linear-gradient(90deg, rgba(255,241,118,0.45), rgba(255,241,118,0.25)); }
    .ad-space { background:#fbfbff; border:2px dashed #e6eefc; padding:16px; border-radius:10px; color:#7b8aa3; text-align:center; }
    pre.corrected { white-space:pre-wrap; word-wrap:break-word; background:#f8fafc; padding:12px; border-radius:8px; border:1px solid #eef2ff; }
  </style>
</head>
<body>
  <div class="container py-4">
    <div class="d-flex justify-content-between align-items-center mb-3">
      <h4 class="mb-0">Grammar Checker</h4>
      <small class="text-muted">Powered by LanguageTool (public API) • Client UI</small>
    </div>

    <div class="ad-space mb-3">Ad Space — paste AdSense here</div>

    <div class="tool-card mx-auto" style="max-width:900px">
      <label class="form-label">Enter text to check</label>
      <textarea id="inputText" rows="8" class="form-control mb-3" placeholder="Paste or type your text here..."></textarea>

      <div class="row g-2 align-items-center mb-3">
        <div class="col-sm-4">
          <label class="form-label mb-0 small">Language</label>
          <select id="lang" class="form-select">
            <option value="auto" selected>Auto-detect</option>
            <option value="en-US">English (US)</option>
            <option value="en-GB">English (UK)</option>
            <option value="es">Spanish</option>
            <option value="fr">French</option>
            <option value="de">German</option>
            <!-- add more if you need -->
          </select>
        </div>
        <div class="col-sm-4">
          <label class="form-label mb-0 small">Confidence threshold</label>
          <input id="minScore" type="range" min="0" max="1" step="0.05" value="0.1" class="form-range">
          <div class="small text-muted">Show suggestions with score ≥ <span id="scoreVal">0.10</span></div>
        </div>
        <div class="col-sm-4 text-end">
          <div class="btn-group" role="group">
            <button id="checkBtn" class="btn btn-primary">Check</button>
            <button id="applyAll" class="btn btn-success" disabled>Apply All</button>
            <button id="clearBtn" class="btn btn-outline-secondary">Clear</button>
          </div>
        </div>
      </div>

      <div id="status" class="mb-2 small text-muted">Ready.</div>

      <div class="row">
        <div class="col-lg-7">
          <div class="mb-2"><strong>Suggestions</strong></div>
          <div id="suggestions" style="max-height:480px; overflow:auto; padding-right:6px;"></div>
        </div>

        <div class="col-lg-5">
          <div class="mb-2"><strong>Corrected Text</strong></div>
          <div id="correctedWrap" class="mb-2">
            <pre id="corrected" class="corrected">No changes yet.</pre>
          </div>
          <div class="d-flex gap-2">
            <button id="copyBtn" class="btn btn-outline-primary btn-sm" disabled>Copy Corrected</button>
            <a id="downloadBtn" class="btn btn-outline-success btn-sm disabled" download="corrected.txt">Download</a>
          </div>
        </div>
      </div>
    </div>

    <div class="ad-space mt-3">Ad Space (Footer)</div>
  </div>

<script>
  const inputText = document.getElementById('inputText');
  const checkBtn = document.getElementById('checkBtn');
  const clearBtn = document.getElementById('clearBtn');
  const suggestionsDiv = document.getElementById('suggestions');
  const statusEl = document.getElementById('status');
  const correctedPre = document.getElementById('corrected');
  const copyBtn = document.getElementById('copyBtn');
  const downloadBtn = document.getElementById('downloadBtn');
  const applyAllBtn = document.getElementById('applyAll');
  const langSelect = document.getElementById('lang');
  const minScore = document.getElementById('minScore');
  const scoreVal = document.getElementById('scoreVal');

  scoreVal.textContent = Number(minScore.value).toFixed(2);

  minScore.addEventListener('input', () => {
    scoreVal.textContent = Number(minScore.value).toFixed(2);
  });

  clearBtn.addEventListener('click', () => {
    inputText.value = '';
    suggestionsDiv.innerHTML = '';
    correctedPre.textContent = 'No changes yet.';
    statusEl.textContent = 'Cleared.';
    copyBtn.disabled = true;
    downloadBtn.classList.add('disabled');
    applyAllBtn.disabled = true;
  });

  // Helper: apply multiple replacements safely
  function applyReplacements(original, matches, useTopSuggestion=true) {
    // matches: array of {offset, length, replacement}
    // Sort by offset desc so earlier replacements don't shift later ones
    const sorted = matches.slice().sort((a,b) => b.offset - a.offset);
    let text = original;
    for (const m of sorted) {
      text = text.slice(0, m.offset) + m.replacement + text.slice(m.offset + m.length);
    }
    return text;
  }

  // Build suggestion UI
  function renderSuggestions(matches, originalText) {
    suggestionsDiv.innerHTML = '';
    if (!matches.length) {
      suggestionsDiv.innerHTML = '<div class="text-muted">No suggestions found.</div>';
      applyAllBtn.disabled = true;
      return;
    }
    applyAllBtn.disabled = false;

    matches.forEach((m, idx) => {
      const container = document.createElement('div');
      container.className = 'result-line p-2 rounded';
      container.style.border = '1px solid #eef2ff';
      container.style.background = '#fff';

      const excerpt = originalText.substr(Math.max(0, m.offset-40), Math.min(200, m.length+80));
      const before = excerpt.slice(0, Math.max(0, 40 - Math.max(0, m.offset-40)));
      const matchText = originalText.substr(m.offset, m.length);
      const after = excerpt.slice(before.length + matchText.length);

      container.innerHTML = `
        <div class="d-flex justify-content-between align-items-start">
          <div style="flex:1">
            <div style="font-size:.95rem; margin-bottom:6px;"><strong>${m.message}</strong></div>
            <div class="small text-muted mb-2">Rule: ${m.ruleId || '—'} • ${m.shortMessage || ''}</div>
            <div style="font-family:monospace; white-space:pre-wrap;">
              ${escapeHtml(before)}<span class="badge bg-warning text-dark">${escapeHtml(matchText)}</span>${escapeHtml(after)}
            </div>
            <div class="mt-2">
              ${m.replacements.map((r,i) => `<button class="btn btn-sm btn-light suggestion me-1" data-idx="${idx}" data-sugg="${escapeHtml(r.value)}">${escapeHtml(r.value)}</button>`).join('')}
              <button class="btn btn-sm btn-outline-secondary ms-1 show-details" data-idx="${idx}">Details</button>
            </div>
          </div>
          <div class="ms-2 text-end small text-muted">
            <div>Offset: ${m.offset}</div>
            <div>Length: ${m.length}</div>
            <div>Score: ${Number(m.ruleIssueType === 'misspelling' ? 0.5 : (m.rule ? (m.rule.category ? 0.6 : 0.3) : 0.4)).toFixed(2)}</div>
          </div>
        </div>
      `;

      // attach click handlers for suggestion buttons
      container.querySelectorAll('.suggestion').forEach(btn => {
        btn.addEventListener('click', () => {
          // apply single suggestion immediately
          const stext = btn.getAttribute('data-sugg');
          const replacement = { offset: m.offset, length: m.length, replacement: stext };
          const newText = applyReplacements(inputText.value, [replacement], true);
          inputText.value = newText;
          statusEl.textContent = 'Applied suggestion — re-run check for new results.';
          correctedPre.textContent = 'Apply All or re-run to see corrected text.';
        });
      });

      // details toggle
      container.querySelector('.show-details').addEventListener('click', (e) => {
        alert(`Rule description:\n\n${m.rule ? (m.rule.description || JSON.stringify(m.rule)) : 'No rule details available.'}`);
      });

      suggestionsDiv.appendChild(container);
    });
  }

  // escape helper
  function escapeHtml(s) {
    return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  }

  // Build corrected text from suggestions
  function buildCorrectedText(original, matches) {
    // for each match pick top replacement if any, else keep original
    const reps = matches.map(m => {
      const replacement = (m.replacements && m.replacements.length) ? m.replacements[0].value : original.substr(m.offset, m.length);
      return { offset: m.offset, length: m.length, replacement };
    });
    return applyReplacements(original, reps, true);
  }

  // Fallback heuristic: very small local checks (basic)
  function localHeuristics(text) {
    const results = [];
    // double spaces
    let idx = text.indexOf('  ');
    while (idx !== -1) {
      results.push({ offset: idx, length: 2, message: 'Double space', replacements: [{value:' '}] });
      idx = text.indexOf('  ', idx+1);
    }
    // sentence starts lower-case
    const sentences = text.match(/[^.!?]+[.!?]?/g) || [];
    let cursor = 0;
    sentences.forEach(s => {
      const trimmed = s.trim();
      if (trimmed && trimmed[0] && trimmed[0] === trimmed[0].toLowerCase() && /[a-zA-Z]/.test(trimmed[0])) {
        const off = text.indexOf(s, cursor);
        if (off !== -1) {
          results.push({ offset: off + s.indexOf(trimmed[0]), length: 1, message: 'Sentence maybe should start with a capital letter', replacements: [{value: trimmed[0].toUpperCase()}]});
        }
      }
      cursor += s.length;
    });
    return results;
  }

  // Main check: call LanguageTool public API
  async function callLanguageTool(text, lang) {
    // endpoint
    const endpoint = 'https://api.languagetool.org/v2/check';
    const params = new URLSearchParams();
    params.append('text', text);
    if (lang && lang !== 'auto') params.append('language', lang);
    else params.append('language', 'auto');

    // Additional options: enabledOnly=false to get more suggestions
    params.append('enabledOnly', 'false');

    const resp = await fetch(endpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: params.toString()
    });
    if (!resp.ok) throw new Error('LanguageTool request failed: ' + resp.status);
    return resp.json();
  }

  checkBtn.addEventListener('click', async () => {
    const text = inputText.value.trim();
    if (!text) { alert('Please paste or type some text to check.'); return; }

    suggestionsDiv.innerHTML = '';
    correctedPre.textContent = 'Working...';
    statusEl.textContent = 'Sending text to LanguageTool...';
    applyAllBtn.disabled = true;
    copyBtn.disabled = true;
    downloadBtn.classList.add('disabled');

    try {
      const ltLang = langSelect.value;
      const data = await callLanguageTool(text, ltLang);
      // data.matches is array
      const rawMatches = (data && data.matches) ? data.matches : [];
      // Normalize matches to our simpler shape:
      const matches = rawMatches
        .filter(m => {
          // filter by score threshold (LanguageTool doesn't always provide numeric score)
          // We'll use a simple heuristic: show all, but allow minScore slider to filter by rule category
          return true;
        })
        .map(m => {
          return {
            offset: m.offset,
            length: m.length,
            message: m.message || m.shortMessage || 'Suggestion',
            replacements: (m.replacements || []).map(r => ({ value: r.value })),
            shortMessage: m.shortMessage || '',
            ruleId: m.rule ? m.rule.id : null,
            rule: m.rule || null
          };
        });

      // If minScore slider > 0.5, filter out punctuation/low importance suggestions roughly by rules (best-effort)
      const minS = parseFloat(minScore.value);
      const filtered = matches.filter(m => {
        if (minS <= 0.1) return true;
        const unimportant = m.rule && m.rule.category && (m.rule.category.id === 'TYPOS' || m.rule.category.id === 'MISC');
        return !unimportant || minS < 0.6;
      });

      // If no matches, try local heuristics
      const finalMatches = filtered.length ? filtered : localHeuristics(text);

      renderSuggestions(finalMatches, text);

      // build corrected text using top replacements
      const corrected = buildCorrectedText(text, finalMatches);
      correctedPre.textContent = corrected || 'No changes.';
      statusEl.textContent = `Completed — ${finalMatches.length} suggestion(s).`;
      copyBtn.disabled = false;
      downloadBtn.classList.remove('disabled');
      // prepare download blob
      const blob = new Blob([corrected], {type: 'text/plain'});
      const dlUrl = URL.createObjectURL(blob);
      downloadBtn.href = dlUrl;

      // store matches for apply all
      window.__lt_matches = finalMatches;
    } catch (err) {
      console.error(err);
      // fallback: local heuristics only
      const local = localHeuristics(text);
      if (local.length) {
        renderSuggestions(local, text);
        const corrected = buildCorrectedText(text, local);
        correctedPre.textContent = corrected;
        statusEl.textContent = 'LanguageTool failed — local heuristics applied.';
        copyBtn.disabled = false;
        downloadBtn.classList.remove('disabled');
        const blob = new Blob([corrected], {type: 'text/plain'});
        downloadBtn.href = URL.createObjectURL(blob);
        window.__lt_matches = local;
      } else {
        suggestionsDiv.innerHTML = '<div class="text-danger">Grammar service currently unavailable. Try again later or host your own LanguageTool server.</div>';
        correctedPre.textContent = '—';
        statusEl.textContent = 'Failed.';
      }
    }
  });

  // Apply All button
  applyAllBtn.addEventListener('click', () => {
    const text = inputText.value || '';
    const matches = window.__lt_matches || [];
    if (!matches.length) { alert('No suggestions to apply.'); return; }
    // confirm
    if (!confirm('Apply all top suggestions to the text? You can undo by using browser Undo (Ctrl+Z).')) return;
    const corrected = buildCorrectedText(text, matches);
    inputText.value = corrected;
    correctedPre.textContent = corrected;
    statusEl.textContent = 'All suggestions applied to textarea.';
    // re-run check optionally
  });

  // copy & download
  copyBtn.addEventListener('click', async () => {
    try {
      await navigator.clipboard.writeText(correctedPre.textContent);
      statusEl.textContent = 'Corrected text copied to clipboard.';
    } catch (e) {
      alert('Copy failed — select the text manually and copy.');
    }
  });
</script>
</body>
</html>
